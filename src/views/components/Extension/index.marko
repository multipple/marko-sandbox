
import * as Plugin from './Plugin'
import * as Application from './MicroApp'

class {
  async onCreate( input ){
    this.state = {
      loaded: false, 
      errmess: false,
      currentLanguage: 'en-US'
    }
    
    this.nsi = input.id || input.nsi
    this.extension = null
    this.root = null

    this.Manager = null
    this.LanguageManifest = null
    this.LanguageDictionary = null
    
    GState.bind( this, [ this.nsi, 'tenant', 'user', 'theme', 'workspace', 'screen', 'locale' ] )
    
    this.resolveRoot( input )
    await this.loadLanguageManifest()
    await this.loadLocaleDictionary( true )
    await this.fetchComponent( this.exactInput( input ) )
  }
  onInput( input ){ this.input = this.exactInput( input ) }
  onMount(){
    // Load the dictionnary of the new language
    GState.on( 'locale', async ({ language, variant }) => {
      if( ( language +'-'+ variant ) === this.state.currentLanguage ) return
      await this.loadLocaleDictionary()
    } )
  }
  
  exactInput( input ){
    const metaset = input.name && !input.nsi ? 
                            { ...input, ...( window.Extensions.meta( input.name ) ) } 
                            : input
                            
    return metaset && metaset.nsi ? metaset : null
  }
  resolveRoot( input ){
    // Get extension path by account type configuration
    const 
    { type, nsi, runscript, version, namespace } = input,
    accountType = this.state.user.accounttype.toLowerCase()
    // Path of the component to load as main package: Default is `index.marko`
    
    // this.root = runscript
    //             && ( ( runscript['*'] && runscript['*'].main ) // Main component for all account
    //             || ( runscript[ accountType ] && runscript[ accountType ].main ) ) // Main component for specific account type
    this.root = ''
  }
  allowedScope( target ){
    
    if( !this.input.resource
        || !this.input.resource.permissions 
        || !Array.isArray( this.input.resource.permissions.scope )
        || !this.input.resource.permissions.scope.length ) return {}

    const scopeData = {}
    let targetData = {}

    switch( target ){
      case 'user': targetData = this.state.user; break
      case 'tenant': targetData = this.state.tenant; break
    }

    function assignValue( link, holder, receiver = {} ){
      
      const
      nsp = link.split('.'),
      toCheck = nsp.shift()

      /* Receiver requesting all data fields contain in the holder
      
        TEMPORARY: Later give a censor list of primary
                    level of fields that can be assign
                    in bulk
      */
      if( toCheck == '*' ){
        Object.assign( receiver, holder )
        return
      }
    
      if( typeof holder == 'object' && !holder.hasOwnProperty( toCheck ) )
        return false
    
      if( typeof holder[ toCheck ] == 'object' && nsp.length ){
        holder = holder[ toCheck ]
        receiver[ toCheck ] = {}
    
        return assignValue( nsp.join('.'), holder, receiver[ toCheck ] )
      }
      
      receiver[ toCheck ] = holder[ toCheck ]
    }
    
    this.input.resource.permissions.scope.map( ({ type, access }) => {
      // Assign granted permission data
      if( type.includes( target ) && access == 'GRANTED' )
        assignValue( type.replace(/^[a-zA-Z0-9]+\./, ''), targetData, scopeData )

      /* TODO: Collect the list of mandatory permission
              to re-ask for
      */
      // if( access == 'MANDATORY' )
      //   assignValue( type.replace(/^[a-zA-Z0-9]+\./, ''), targetData, scopeData )
    } )
    
    return scopeData
  }
  throwError( error ){

    if( error === false ){
      this.state.errmess = false
      return
    }

    console.log( error )
    window.GTrace.throw( error )
    this.state.errmess = error.message
  }

  Refresh(){ window.Extensions.list[ this.input.name ].refresh() }
  Request( options ){
    return new Promise( ( resolve, reject ) => {
      window.Request( '/extension/request', 'POST', options )
            .then( resolve )
            .catch( error => {
              this.throwError( error )
              reject( error )
            })
    } )
  }
  Emit( ...args ){
    this.emit( ...args )
    this.emit('forward', ...args )
    this.emit('test-event', ...args )
    
    console.log('Output Event: ', ...args )
  }
  Debug( message, data, status, trace ){
    // debugLog( `[${this.input.name}]`, message )
    // Emit log to emulator
    const dataset = { name: this.input.name, type: 'debug', message, data, status, trace }
    window.iof && window.iof.emit( 'console:log', dataset )
  }
  RenderLocale( text ){
    /* Static translation
      {
        ...
        "User account": "Compte utilisateur",
        ...
      }
    */
    const [ language, variant ] = this.state.currentLanguage.split('-')
    let translation = // Check dictionary provided by the extension
                      ( this.LanguageDictionary && this.LanguageDictionary[ text ] )
                      // Check in global dictionnary: Standard Words/Terms
                      // || ( this.state.locale && this.state.local.dictionary[ text ] )
                      // Fallback to original text
                      || text

    /* Select defined variance
      {
        ...
        "Buy now": {
            "US": "Buy now",
            "UK": "Purchase now",
            "default": "US"
        }
        ...
      }
    */
    if( typeof translation == 'object' ){
      // Specified variant defined
      if( variant
          && translation.hasOwnProperty( variant ) )
        translation = translation[ variant ]

      // User default define variant
      else {
        const defaultVariant = translation['default']

        translation = ( defaultVariant
                        && translation[ defaultVariant ] )
                      || text
      }
    }

    return translation
  }
  Quit(){
    this.input.type == 'application' && this.destroy() // Auto-close when it's a micro-app
    this.Emit('quit')
  }
  
  async fetchComponent( input ){
    
    if( !input ) return
    try {
      // Fetch Marko template targeting available version
      this.extension = await import(`root/${this.root}`)
      // Initialize extension manager
      this.Manager = input.type == 'application' ? new Application.Manager( this ) : new Plugin.Manager( this )

      this.state.loaded = true
    }
    catch( error ){ this.throwError( error ) }
  }
  async loadLanguageManifest(){
    // Load defined locale language translation manifest.json file
    this.LanguageManifest = require(`root/${this.root}locales/manifest.json`)
    // Send language manifest to emulator
    if( !window.iof ) return
    window.iof.off('get:languages') // Remove previous listener
    window.iof.on( 'get:languages', fn => typeof fn == 'function' && fn( false, this.LanguageManifest ) )
  }
  async loadLocaleDictionary( activate ){
    // Load current locale language's provided Dictionary
    if( !this.LanguageManifest ){
      activate && this.throwError( new Error('Locale languages manifest not found') )
      return
    }

    const 
    currentLanguage = this.state.locale.language || this.state.currentLanguage,
    [ language, variant ] = currentLanguage.split('-')

    // Fetch another dictionary
    try {
      const locale = this.LanguageManifest[ language ]
      if( !locale ) 
        throw new Error(`${locale} language dictionary not found`)

      this.LanguageDictionary = await import(`root/${this.root}locales/${locale.dictionary}`)
      this.setState({ errmess: false, currentLanguage })
    }
    catch( error ){ this.throwError( error ) }

    return this.RenderLocale
  }
}

<TryCatch>
  <if( !state.errmess )>
    <!-- Extension loading stage -->
    <if( state.loaded === false )>
      <Loading ...input/>
    </if>
    <else-if( component.extension )>
      <!-- Render the extension -->
      $ {
        // Assign all extension infos to itself as `meta`
        const meta = newObject( input )
        delete meta.payload
      }
      
      <context locale=state.locale
                RenderLocale=component.RenderLocale.bind( component )>
        <${component.extension} meta=meta
                                action=(state[ component.nsi ] ? state[ component.nsi ].action : input.action)
                                payload=(state[ component.nsi ] ? state[ component.nsi ].payload : input.payload)
                                theme=state.theme
                                screen=state.screen
                                mode=state.workspace.mode
                                context=state.workspace.context
                                user=component.allowedScope('user')
                                tenant=component.allowedScope('tenant')
                                Declare=( component.Manager && component.Manager.bind )/>
      </context>
    </else-if>
  </if>
  <else>
    <!-- Error encounted when loading extension -->
    <div class="h-100 d-flex align-items-center">
      <div class="w-100 text-center" key="error-block">
        <i class="bx bx-error font-large-3" style="color:inherit"></i>
        <br><br>
        <p style="padding:0 10%">
          Oops! ${state.errmess}
        </p>
      </div>
    </div>
  </else>
</TryCatch>